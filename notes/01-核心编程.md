## 深浅拷贝

1. 浅拷贝:对于一个对象的顶层拷贝

   拷贝了引用，没有拷贝内容，这个就是只将a 的地址传给b

   ```
   In [11]: a= [1,2,3]
   
   In [12]: b=a
   
   In [13]: id(a)
   Out[13]: 139647744601736
   
   In [14]: id(b)
   Out[14]: 139647744601736
   
   ```

2. 深拷贝：

   ```
   In [15]: import copy
   
   In [16]: a= [1,2,3]
   
   In [17]: b = copy.deepcopy(a)
   
   In [18]: id(a)
   Out[18]: 139647744572552
   
   In [19]: id(b)
   Out[19]: 139647805583304
   
   ```

   将a中的值拷贝到b 他们的地址保持不一样

   验证区别：

   ```
   In [34]: a=[1,2,3,4]
   In [35]: b=a
   In [36]: a
   Out[36]: [1, 2, 3, 4]
   In [37]: b
   Out[37]: [1, 2, 3, 4]
   In [38]: c = copy.deepcopy(a)
   In [39]: c
   Out[39]: [1, 2, 3, 4]
   In [40]: a.append(2)
   In [41]: a
   Out[41]: [1, 2, 3, 4, 2]
   In [42]: b
   Out[42]: [1, 2, 3, 4, 2]
   In [43]: c
   Out[43]: [1, 2, 3, 4]
   ```

   注意：深拷贝，如果拷贝的内容利包含有其他引用将进行递归拷贝

   区别copy.deepcopy 与copy.copy 

   deepcopy 为深度拷贝

   copy 为半深度拷贝，只识别第一层的，如果在内容中包括了地址，地址将被一起拷贝过来，而第一层的地址会不同，但是注意，元祖第一层也不会变（即不可变类型）

   

------

### 二进制计算：

在使用乘除时，使用位运算会节省内存，并且效率会大大提高

### 私有化：

私有化即是对变量或者函数进行私密定义，也就是在一个类中，如果有私有话的函数 ，或者变量，将不能从外部调用或者改变。

私有话形式：私有化就是子啊变量名前面加上两个下划线

### 实例：

```
daf __siyouhua(self):#函数

self.__siyoubianliang=xxx
```

了解常用专有属性：			

|     专有属性      |         说明          |               触发方式               |
| :---------------: | :-------------------: | :----------------------------------: |
|    \_\_init__     |    构造初始化函数     | 创建实例后,赋值时使用,在`__new__`后  |
|     _\_new__      |   生成实例所需属性    |              创建实例时              |
|    \__class__     |     实例所在的类      |           实例.`__class__`           |
|     \__str__      | 实例字符串表示,可读性 | print(类实例),如没实现，使用repr结果 |
|     \__repr__     | 实例字符串表示,准确性 | 类实例 回车 或者 print(repr(类实例)) |
|     \__del__      |         析构          |             del删除实例              |
| \__getattribute__ |    属性访问拦截器     |            访问实例属性时            |

 属性拦截：





```
   class Person(object):
        def __getattribute__(self,obj):
            print("---test---")
            if obj.startswith("a"):
                return "hahha"
            else:
                return self.test


        def test(self):
            print("heihei")


    t=Person()
    t.a : "hahaha"
    t.b：erro
    #会让程序死掉
        #原因是：当t.b执行时，会调用Person类中定义的__getattribute__方法，但是在这个方法的执行过程中
        #if条件不满足，所以 程序执行else里面的代码，即return self.test  问题就在这，因为return 需要把
        #self.test的值返回，那么首先要获取self.test的值，因为self此时就是t这个对象，所以self.test就是
        #t.test 此时要获取t这个对象的test属性，那么就会跳转到__getattribute__方法去执行，即此时产
        #生了递归调用，由于这个递归过程中 没有判断什么时候推出，所以这个程序会永无休止的运行下去，又因为
        #每次调用函数，就需要保存一些数据，那么随着调用的次数越来越多，最终内存吃光，所以程序 崩溃
        #
        # 注意：以后不要在__getattribute__方法中调用self.xxxx
    
```





### property的使用：

在类中设置了私有属性时，我们想要更改，那么就必须通过类中的函数间接来更改器属性值，但是在开发过程中我们为了方便可以使用property来间接调用函数，将自动查找我们想完成什么事情。



```
#使用方法一：在类的最后与函数定义同一级写下该方法:
num = property(getnum,setnum)

在主函数中只需要 test = 类（）
test.num =10  #设置参数 自动调用setnum方法

print(test.num) #获取参数，自动调用getnum方法

方法二：使用装饰器方式设置
@property
def num(self):
	#设置参数
@num.property
def num(self):
	#输出参数
	
调用方式相同
```







